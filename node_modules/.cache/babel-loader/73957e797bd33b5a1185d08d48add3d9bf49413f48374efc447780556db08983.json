{"ast":null,"code":"/**\n * @module ol/reproj/glreproj\n */\nimport * as mat4 from '../vec/mat4.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../has.js';\nimport { Canvas as WebGLCanvas, createProgram } from '../webgl/Canvas.js';\nimport { createEmpty, extend, getHeight, getTopLeft, getWidth } from '../extent.js';\nconst EDGE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n  }\n`;\nconst EDGE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  uniform vec4 u_val;\n  void main() {\n     gl_FragColor = u_val;\n  }\n`;\nconst TRIANGLE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec2 a_texcoord;\n\n  varying vec2 v_texcoord;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n     v_texcoord = a_texcoord;\n  }\n`;\nconst TRIANGLE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/**\n * Create an html canvas element and returns its webgl context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings\n * @return {WebGLRenderingContext} The context.\n */\nexport function createCanvasContextWebGL(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = /** @type {HTMLCanvasElement} */canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {WebGLRenderingContext} */canvas.getContext('webgl', settings);\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {WebGLRenderingContext} gl Context.\n */\nexport function releaseGLCanvas(gl) {\n  const canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n}\n\n/**\n * @type {Array<HTMLCanvasElement | OffscreenCanvas>}\n */\nexport const canvasGLPool = [];\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"../extent.js\").Extent} extent Extent.\n * @property {import(\"../extent.js\").Extent} [clipExtent] Clip extent.\n * @property {WebGLTexture} texture Texture.\n * @property {number} width Width of texture.\n * @property {number} height Height of texture.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {WebGLRenderingContext} gl the context to render in.\n * @param {number} width_ Width of the canvas.\n * @param {number} height_ Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"../extent.js\").Extent} targetExtent Target extent (tile).\n * @param {import(\"../reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE\n * TODO: Allow setting renderEdges value in the data as this is done in \"data-space\".\n * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.\n * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.\n */\nexport function render(gl, width_, height_, pixelRatio, sourceResolution, targetResolution, targetExtent, triangulation, sources, gutter, dataType, renderEdges, interpolate, drawSingle) {\n  const width = Math.round(pixelRatio * width_);\n  const height = Math.round(pixelRatio * height_);\n  gl.canvas.width = width;\n  gl.canvas.height = height;\n\n  /** @type {WebGLFramebuffer | null} */\n  let resultFrameBuffer;\n  /** @type {WebGLTexture | null} */\n  let resultTexture;\n  {\n    resultTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, resultTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, dataType, null);\n    resultFrameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, resultTexture, 0);\n  }\n  if (resultFrameBuffer === null) {\n    throw new Error('Could not create framebuffer');\n  }\n  if (resultTexture === null) {\n    throw new Error('Could not create texture');\n  }\n  if (sources.length === 0) {\n    return {\n      width,\n      height,\n      framebuffer: resultFrameBuffer,\n      texture: resultTexture\n    };\n  }\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  /** @type {WebGLTexture | null} */\n  let stitchTexture;\n  /** @type {number} */\n  let stitchWidth;\n  /** @type {number} */\n  let stitchHeight;\n  const stitchScale = 1 / sourceResolution;\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchTexture = gl.createTexture();\n    if (resultTexture === null) {\n      throw new Error('Could not create texture');\n    }\n    stitchWidth = Math.round(getWidth(sourceDataExtent) * stitchScale);\n    stitchHeight = Math.round(getHeight(sourceDataExtent) * stitchScale);\n\n    // Make sure we do not exceed the max texture size by lowering the resolution for this image.\n    // https://github.com/openlayers/openlayers/pull/15860#issuecomment-2254123580\n    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    const largeSide = Math.max(stitchWidth, stitchHeight);\n    const scaleFactor = largeSide > maxTexSize ? maxTexSize / largeSide : 1;\n    const stitchWidthFixed = Math.round(stitchWidth * scaleFactor);\n    const stitchHeightFixed = Math.round(stitchHeight * scaleFactor);\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, stitchWidthFixed, stitchHeightFixed, 0, gl.RGBA, dataType, null);\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, stitchTexture, 0);\n    const webGLCanvas = new WebGLCanvas(gl);\n    sources.forEach(function (src, i, arr) {\n      const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n      const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\n      const srcWidth = getWidth(src.extent) * stitchScale * scaleFactor;\n      const srcHeight = getHeight(src.extent) * stitchScale * scaleFactor;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n      gl.viewport(0, 0, stitchWidthFixed, stitchHeightFixed);\n      if (src.clipExtent) {\n        const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n        const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\n        const width = getWidth(src.clipExtent) * stitchScale * scaleFactor;\n        const height = getHeight(src.clipExtent) * stitchScale * scaleFactor;\n        gl.enable(gl.SCISSOR_TEST);\n        gl.scissor(interpolate ? xPos : Math.round(xPos), interpolate ? yPos : Math.round(yPos), interpolate ? width : Math.round(xPos + width) - Math.round(xPos), interpolate ? height : Math.round(yPos + height) - Math.round(yPos));\n      }\n      webGLCanvas.drawImage(src.texture, src.width, src.height, gutter, gutter, src.width - 2 * gutter, src.height - 2 * gutter, interpolate ? xPos : Math.round(xPos), interpolate ? yPos : Math.round(yPos), interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos), interpolate ? srcHeight : Math.round(yPos + srcHeight) - Math.round(yPos), stitchWidthFixed, stitchHeightFixed);\n      gl.disable(gl.SCISSOR_TEST);\n    });\n    gl.deleteFramebuffer(fb);\n  } else {\n    stitchTexture = sources[0].texture;\n    stitchWidth = sources[0].width;\n    stitchHeight = sources[0].width;\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n  const sourceTopLeft = getTopLeft(sourceDataExtent);\n  const getUVs = (/** @type {Array<import(\"../coordinate.js\").Coordinate>} */target) => {\n    const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution * pixelRatio;\n    const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution * pixelRatio;\n    const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution * pixelRatio;\n    const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution * pixelRatio;\n    const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution * pixelRatio;\n    const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution * pixelRatio;\n    return {\n      u1,\n      v1,\n      u0,\n      v0,\n      u2,\n      v2\n    };\n  };\n  gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n  gl.viewport(0, 0, width, height);\n\n  // Draw source to reprojtile\n  {\n    /** @type {Array<number>} */\n    const vertices = [];\n    /** @type {Array<number>} */\n    const texcoords = [];\n    const triProgram = createProgram(gl, TRIANGLE_FRAGMENT_SHADER, TRIANGLE_VERTEX_SHADER);\n    gl.useProgram(triProgram);\n\n    // Bind image\n    const textureLocation = gl.getUniformLocation(triProgram, 'u_texture');\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    // Tell the shader to get the texture from texture unit 0\n    gl.uniform1i(textureLocation, 0);\n\n    // Calculate vert and tex coordinates.\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const source = triangle.source;\n      const target = triangle.target;\n      // Make sure that everything is on pixel boundaries\n      const {\n        u1,\n        v1,\n        u0,\n        v0,\n        u2,\n        v2\n      } = getUVs(target);\n      const su0 = (source[0][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv0 = -(source[0][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su1 = (source[1][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv1 = -(source[1][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su2 = (source[2][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv2 = -(source[2][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      vertices.push(u1, v1, u0, v0, u2, v2);\n      texcoords.push(su1, sv1, su0, sv0, su2, sv2);\n    });\n\n    // Convert pixel space to clip space.\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(triProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n    const positionLocation = gl.getAttribLocation(triProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n    const texcoordLocation = gl.getAttribLocation(triProgram, 'a_texcoord');\n    const texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(texcoordLocation);\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);\n  }\n  if (renderEdges) {\n    const edgeProgram = createProgram(gl, EDGE_FRAGMENT_SHADER, EDGE_VERTEX_SHADER);\n    gl.useProgram(edgeProgram);\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(edgeProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n    const burnval = Array.isArray(renderEdges) ? renderEdges : [0, 0, 0, 255];\n    const burnvalLocation = gl.getUniformLocation(edgeProgram, 'u_val');\n    const isFloat = true;\n    if (isFloat) {\n      gl.uniform4fv(burnvalLocation, burnval);\n    } else {\n      gl.uniform4iv(burnvalLocation, burnval);\n    }\n    const positionLocation = gl.getAttribLocation(edgeProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    /** @type {Array<number>} */\n    const lines = triangulation.getTriangles().reduce(function (/** @type {Array<number>} */lines, triangle) {\n      const target = triangle.target;\n      const {\n        u1,\n        v1,\n        u0,\n        v0,\n        u2,\n        v2\n      } = getUVs(target);\n      return lines.concat([u1, v1, u0, v0, u0, v0, u2, v2, u2, v2, u1, v1]);\n    }, []);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);\n    gl.drawArrays(gl.LINES, 0, lines.length / 2);\n  }\n  return {\n    width,\n    height,\n    framebuffer: resultFrameBuffer,\n    texture: resultTexture\n  };\n}","map":{"version":3,"names":["mat4","WORKER_OFFSCREEN_CANVAS","Canvas","WebGLCanvas","createProgram","createEmpty","extend","getHeight","getTopLeft","getWidth","EDGE_VERTEX_SHADER","EDGE_FRAGMENT_SHADER","TRIANGLE_VERTEX_SHADER","TRIANGLE_FRAGMENT_SHADER","createCanvasContextWebGL","width","height","canvasPool","settings","canvas","length","shift","OffscreenCanvas","document","createElement","getContext","releaseGLCanvas","gl","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","canvasGLPool","render","width_","height_","pixelRatio","sourceResolution","targetResolution","targetExtent","triangulation","sources","gutter","dataType","renderEdges","interpolate","drawSingle","Math","round","resultFrameBuffer","resultTexture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","NEAREST","texImage2D","RGBA","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","Error","framebuffer","texture","sourceDataExtent","forEach","src","i","arr","extent","stitchTexture","stitchWidth","stitchHeight","stitchScale","maxTexSize","getParameter","MAX_TEXTURE_SIZE","largeSide","max","scaleFactor","stitchWidthFixed","stitchHeightFixed","fb","webGLCanvas","xPos","yPos","srcWidth","srcHeight","viewport","clipExtent","enable","SCISSOR_TEST","scissor","drawImage","disable","deleteFramebuffer","targetTopLeft","sourceTopLeft","getUVs","target","u0","v0","u1","v1","u2","v2","vertices","texcoords","triProgram","useProgram","textureLocation","getUniformLocation","uniform1i","getTriangles","triangle","source","su0","sv0","su1","sv1","su2","sv2","push","matrix","orthographic","matrixLocation","uniformMatrix4fv","positionLocation","getAttribLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","vertexAttribPointer","FLOAT","enableVertexAttribArray","texcoordLocation","texcoordBuffer","drawArrays","TRIANGLES","edgeProgram","burnval","Array","isArray","burnvalLocation","isFloat","uniform4fv","uniform4iv","lines","reduce","concat","LINES"],"sources":["C:/Users/zachm/flask-react-frontend/node_modules/ol/reproj/glreproj.js"],"sourcesContent":["/**\n * @module ol/reproj/glreproj\n */\nimport * as mat4 from '../vec/mat4.js';\nimport {WORKER_OFFSCREEN_CANVAS} from '../has.js';\nimport {Canvas as WebGLCanvas, createProgram} from '../webgl/Canvas.js';\nimport {\n  createEmpty,\n  extend,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from '../extent.js';\n\nconst EDGE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n  }\n`;\nconst EDGE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  uniform vec4 u_val;\n  void main() {\n     gl_FragColor = u_val;\n  }\n`;\n\nconst TRIANGLE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec2 a_texcoord;\n\n  varying vec2 v_texcoord;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n     v_texcoord = a_texcoord;\n  }\n`;\nconst TRIANGLE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/**\n * Create an html canvas element and returns its webgl context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings\n * @return {WebGLRenderingContext} The context.\n */\nexport function createCanvasContextWebGL(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {WebGLRenderingContext} */ (\n    canvas.getContext('webgl', settings)\n  );\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {WebGLRenderingContext} gl Context.\n */\nexport function releaseGLCanvas(gl) {\n  const canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n}\n\n/**\n * @type {Array<HTMLCanvasElement | OffscreenCanvas>}\n */\nexport const canvasGLPool = [];\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"../extent.js\").Extent} extent Extent.\n * @property {import(\"../extent.js\").Extent} [clipExtent] Clip extent.\n * @property {WebGLTexture} texture Texture.\n * @property {number} width Width of texture.\n * @property {number} height Height of texture.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {WebGLRenderingContext} gl the context to render in.\n * @param {number} width_ Width of the canvas.\n * @param {number} height_ Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"../extent.js\").Extent} targetExtent Target extent (tile).\n * @param {import(\"../reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE\n * TODO: Allow setting renderEdges value in the data as this is done in \"data-space\".\n * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.\n * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.\n */\nexport function render(\n  gl,\n  width_,\n  height_,\n  pixelRatio,\n  sourceResolution,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  dataType,\n  renderEdges,\n  interpolate,\n  drawSingle,\n) {\n  const width = Math.round(pixelRatio * width_);\n  const height = Math.round(pixelRatio * height_);\n  gl.canvas.width = width;\n  gl.canvas.height = height;\n\n  /** @type {WebGLFramebuffer | null} */\n  let resultFrameBuffer;\n  /** @type {WebGLTexture | null} */\n  let resultTexture;\n  {\n    resultTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, resultTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    resultFrameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      resultTexture,\n      0,\n    );\n  }\n\n  if (resultFrameBuffer === null) {\n    throw new Error('Could not create framebuffer');\n  }\n  if (resultTexture === null) {\n    throw new Error('Could not create texture');\n  }\n\n  if (sources.length === 0) {\n    return {\n      width,\n      height,\n      framebuffer: resultFrameBuffer,\n      texture: resultTexture,\n    };\n  }\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  /** @type {WebGLTexture | null} */\n  let stitchTexture;\n  /** @type {number} */\n  let stitchWidth;\n  /** @type {number} */\n  let stitchHeight;\n  const stitchScale = 1 / sourceResolution;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchTexture = gl.createTexture();\n    if (resultTexture === null) {\n      throw new Error('Could not create texture');\n    }\n    stitchWidth = Math.round(getWidth(sourceDataExtent) * stitchScale);\n    stitchHeight = Math.round(getHeight(sourceDataExtent) * stitchScale);\n\n    // Make sure we do not exceed the max texture size by lowering the resolution for this image.\n    // https://github.com/openlayers/openlayers/pull/15860#issuecomment-2254123580\n    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    const largeSide = Math.max(stitchWidth, stitchHeight);\n    const scaleFactor = largeSide > maxTexSize ? maxTexSize / largeSide : 1;\n    const stitchWidthFixed = Math.round(stitchWidth * scaleFactor);\n    const stitchHeightFixed = Math.round(stitchHeight * scaleFactor);\n\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      stitchWidthFixed,\n      stitchHeightFixed,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      stitchTexture,\n      0,\n    );\n    const webGLCanvas = new WebGLCanvas(gl);\n\n    sources.forEach(function (src, i, arr) {\n      const xPos =\n        (src.extent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n      const yPos =\n        -(src.extent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\n      const srcWidth = getWidth(src.extent) * stitchScale * scaleFactor;\n      const srcHeight = getHeight(src.extent) * stitchScale * scaleFactor;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n      gl.viewport(0, 0, stitchWidthFixed, stitchHeightFixed);\n\n      if (src.clipExtent) {\n        const xPos =\n          (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n        const yPos =\n          -(src.clipExtent[3] - sourceDataExtent[3]) *\n          stitchScale *\n          scaleFactor;\n        const width = getWidth(src.clipExtent) * stitchScale * scaleFactor;\n        const height = getHeight(src.clipExtent) * stitchScale * scaleFactor;\n        gl.enable(gl.SCISSOR_TEST);\n        gl.scissor(\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n          interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n        );\n      }\n\n      webGLCanvas.drawImage(\n        src.texture,\n        src.width,\n        src.height,\n        gutter,\n        gutter,\n        src.width - 2 * gutter,\n        src.height - 2 * gutter,\n        interpolate ? xPos : Math.round(xPos),\n        interpolate ? yPos : Math.round(yPos),\n        interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),\n        interpolate\n          ? srcHeight\n          : Math.round(yPos + srcHeight) - Math.round(yPos),\n        stitchWidthFixed,\n        stitchHeightFixed,\n      );\n\n      gl.disable(gl.SCISSOR_TEST);\n    });\n    gl.deleteFramebuffer(fb);\n  } else {\n    stitchTexture = sources[0].texture;\n    stitchWidth = sources[0].width;\n    stitchHeight = sources[0].width;\n  }\n\n  const targetTopLeft = getTopLeft(targetExtent);\n  const sourceTopLeft = getTopLeft(sourceDataExtent);\n\n  const getUVs = (\n    /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ target,\n  ) => {\n    const u0 =\n      ((target[0][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v0 =\n      (-(target[0][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u1 =\n      ((target[1][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v1 =\n      (-(target[1][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u2 =\n      ((target[2][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v2 =\n      (-(target[2][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    return {u1, v1, u0, v0, u2, v2};\n  };\n\n  gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n  gl.viewport(0, 0, width, height);\n\n  // Draw source to reprojtile\n  {\n    /** @type {Array<number>} */\n    const vertices = [];\n    /** @type {Array<number>} */\n    const texcoords = [];\n\n    const triProgram = createProgram(\n      gl,\n      TRIANGLE_FRAGMENT_SHADER,\n      TRIANGLE_VERTEX_SHADER,\n    );\n    gl.useProgram(triProgram);\n\n    // Bind image\n    const textureLocation = gl.getUniformLocation(triProgram, 'u_texture');\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    // Tell the shader to get the texture from texture unit 0\n    gl.uniform1i(textureLocation, 0);\n\n    // Calculate vert and tex coordinates.\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const source = triangle.source;\n      const target = triangle.target;\n      // Make sure that everything is on pixel boundaries\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      const su0 =\n        (source[0][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv0 =\n        -(source[0][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su1 =\n        (source[1][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv1 =\n        -(source[1][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su2 =\n        (source[2][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv2 =\n        -(source[2][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n\n      vertices.push(u1, v1, u0, v0, u2, v2);\n      texcoords.push(su1, sv1, su0, sv0, su2, sv2);\n    });\n\n    // Convert pixel space to clip space.\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(triProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const positionLocation = gl.getAttribLocation(triProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    const texcoordLocation = gl.getAttribLocation(triProgram, 'a_texcoord');\n    const texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(texcoordLocation);\n\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);\n  }\n\n  if (renderEdges) {\n    const edgeProgram = createProgram(\n      gl,\n      EDGE_FRAGMENT_SHADER,\n      EDGE_VERTEX_SHADER,\n    );\n    gl.useProgram(edgeProgram);\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(edgeProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const burnval = Array.isArray(renderEdges) ? renderEdges : [0, 0, 0, 255];\n    const burnvalLocation = gl.getUniformLocation(edgeProgram, 'u_val');\n    const isFloat = true;\n    if (isFloat) {\n      gl.uniform4fv(burnvalLocation, burnval);\n    } else {\n      gl.uniform4iv(burnvalLocation, burnval);\n    }\n\n    const positionLocation = gl.getAttribLocation(edgeProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    /** @type {Array<number>} */\n    const lines = triangulation.getTriangles().reduce(function (\n      /** @type {Array<number>} */ lines,\n      triangle,\n    ) {\n      const target = triangle.target;\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      return lines.concat([u1, v1, u0, v0, u0, v0, u2, v2, u2, v2, u1, v1]);\n    }, []);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);\n    gl.drawArrays(gl.LINES, 0, lines.length / 2);\n  }\n\n  return {\n    width,\n    height,\n    framebuffer: resultFrameBuffer,\n    texture: resultTexture,\n  };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,KAAKA,IAAI,MAAM,gBAAgB;AACtC,SAAQC,uBAAuB,QAAO,WAAW;AACjD,SAAQC,MAAM,IAAIC,WAAW,EAAEC,aAAa,QAAO,oBAAoB;AACvE,SACEC,WAAW,EACXC,MAAM,EACNC,SAAS,EACTC,UAAU,EACVC,QAAQ,QACH,cAAc;AAErB,MAAMC,kBAAkB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,MAAMC,oBAAoB,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,sBAAsB,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,MAAMC,wBAAwB,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,wBAAwBA,CAACC,KAAK,EAAEC,MAAM,EAAEC,UAAU,EAAEC,QAAQ,EAAE;EAC5E;EACA,IAAIC,MAAM;EACV,IAAIF,UAAU,IAAIA,UAAU,CAACG,MAAM,EAAE;IACnCD,MAAM,GAAG,gCAAkCF,UAAU,CAACI,KAAK,CAAC,CAAE;EAChE,CAAC,MAAM,IAAIpB,uBAAuB,EAAE;IAClCkB,MAAM,GAAG,IAAIG,eAAe,CAACP,KAAK,IAAI,GAAG,EAAEC,MAAM,IAAI,GAAG,CAAC;EAC3D,CAAC,MAAM;IACLG,MAAM,GAAGI,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;EAC3C;EACA,IAAIT,KAAK,EAAE;IACTI,MAAM,CAACJ,KAAK,GAAGA,KAAK;EACtB;EACA,IAAIC,MAAM,EAAE;IACVG,MAAM,CAACH,MAAM,GAAGA,MAAM;EACxB;EACA;EACA,OAAO,oCACLG,MAAM,CAACM,UAAU,CAAC,OAAO,EAAEP,QAAQ,CAAC;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASQ,eAAeA,CAACC,EAAE,EAAE;EAClC,MAAMR,MAAM,GAAGQ,EAAE,CAACR,MAAM;EACxBA,MAAM,CAACJ,KAAK,GAAG,CAAC;EAChBI,MAAM,CAACH,MAAM,GAAG,CAAC;EACjBW,EAAE,CAACC,KAAK,CAACD,EAAE,CAACE,gBAAgB,GAAGF,EAAE,CAACG,gBAAgB,GAAGH,EAAE,CAACI,kBAAkB,CAAC;AAC7E;;AAEA;AACA;AACA;AACA,OAAO,MAAMC,YAAY,GAAG,EAAE;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAMA,CACpBN,EAAE,EACFO,MAAM,EACNC,OAAO,EACPC,UAAU,EACVC,gBAAgB,EAChBC,gBAAgB,EAChBC,YAAY,EACZC,aAAa,EACbC,OAAO,EACPC,MAAM,EACNC,QAAQ,EACRC,WAAW,EACXC,WAAW,EACXC,UAAU,EACV;EACA,MAAM/B,KAAK,GAAGgC,IAAI,CAACC,KAAK,CAACZ,UAAU,GAAGF,MAAM,CAAC;EAC7C,MAAMlB,MAAM,GAAG+B,IAAI,CAACC,KAAK,CAACZ,UAAU,GAAGD,OAAO,CAAC;EAC/CR,EAAE,CAACR,MAAM,CAACJ,KAAK,GAAGA,KAAK;EACvBY,EAAE,CAACR,MAAM,CAACH,MAAM,GAAGA,MAAM;;EAEzB;EACA,IAAIiC,iBAAiB;EACrB;EACA,IAAIC,aAAa;EACjB;IACEA,aAAa,GAAGvB,EAAE,CAACwB,aAAa,CAAC,CAAC;IAClCxB,EAAE,CAACyB,WAAW,CAACzB,EAAE,CAAC0B,UAAU,EAAEH,aAAa,CAAC;IAE5CvB,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAAC4B,cAAc,EAAE5B,EAAE,CAAC6B,aAAa,CAAC;IACpE7B,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAAC8B,cAAc,EAAE9B,EAAE,CAAC6B,aAAa,CAAC;IACpE,IAAIX,WAAW,EAAE;MACflB,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAAC+B,kBAAkB,EAAE/B,EAAE,CAACgC,MAAM,CAAC;MACjEhC,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAACiC,kBAAkB,EAAEjC,EAAE,CAACgC,MAAM,CAAC;IACnE,CAAC,MAAM;MACLhC,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAAC+B,kBAAkB,EAAE/B,EAAE,CAACkC,OAAO,CAAC;MAClElC,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAACiC,kBAAkB,EAAEjC,EAAE,CAACkC,OAAO,CAAC;IACpE;IACAlC,EAAE,CAACmC,UAAU,CACXnC,EAAE,CAAC0B,UAAU,EACb,CAAC,EACD1B,EAAE,CAACoC,IAAI,EACPhD,KAAK,EACLC,MAAM,EACN,CAAC,EACDW,EAAE,CAACoC,IAAI,EACPpB,QAAQ,EACR,IACF,CAAC;IAEDM,iBAAiB,GAAGtB,EAAE,CAACqC,iBAAiB,CAAC,CAAC;IAC1CrC,EAAE,CAACsC,eAAe,CAACtC,EAAE,CAACuC,WAAW,EAAEjB,iBAAiB,CAAC;IACrDtB,EAAE,CAACwC,oBAAoB,CACrBxC,EAAE,CAACuC,WAAW,EACdvC,EAAE,CAACyC,iBAAiB,EACpBzC,EAAE,CAAC0B,UAAU,EACbH,aAAa,EACb,CACF,CAAC;EACH;EAEA,IAAID,iBAAiB,KAAK,IAAI,EAAE;IAC9B,MAAM,IAAIoB,KAAK,CAAC,8BAA8B,CAAC;EACjD;EACA,IAAInB,aAAa,KAAK,IAAI,EAAE;IAC1B,MAAM,IAAImB,KAAK,CAAC,0BAA0B,CAAC;EAC7C;EAEA,IAAI5B,OAAO,CAACrB,MAAM,KAAK,CAAC,EAAE;IACxB,OAAO;MACLL,KAAK;MACLC,MAAM;MACNsD,WAAW,EAAErB,iBAAiB;MAC9BsB,OAAO,EAAErB;IACX,CAAC;EACH;EAEA,MAAMsB,gBAAgB,GAAGnE,WAAW,CAAC,CAAC;EACtCoC,OAAO,CAACgC,OAAO,CAAC,UAAUC,GAAG,EAAEC,CAAC,EAAEC,GAAG,EAAE;IACrCtE,MAAM,CAACkE,gBAAgB,EAAEE,GAAG,CAACG,MAAM,CAAC;EACtC,CAAC,CAAC;;EAEF;EACA,IAAIC,aAAa;EACjB;EACA,IAAIC,WAAW;EACf;EACA,IAAIC,YAAY;EAChB,MAAMC,WAAW,GAAG,CAAC,GAAG5C,gBAAgB;EAExC,IAAI,CAACS,UAAU,IAAIL,OAAO,CAACrB,MAAM,KAAK,CAAC,IAAIsB,MAAM,KAAK,CAAC,EAAE;IACvDoC,aAAa,GAAGnD,EAAE,CAACwB,aAAa,CAAC,CAAC;IAClC,IAAID,aAAa,KAAK,IAAI,EAAE;MAC1B,MAAM,IAAImB,KAAK,CAAC,0BAA0B,CAAC;IAC7C;IACAU,WAAW,GAAGhC,IAAI,CAACC,KAAK,CAACvC,QAAQ,CAAC+D,gBAAgB,CAAC,GAAGS,WAAW,CAAC;IAClED,YAAY,GAAGjC,IAAI,CAACC,KAAK,CAACzC,SAAS,CAACiE,gBAAgB,CAAC,GAAGS,WAAW,CAAC;;IAEpE;IACA;IACA,MAAMC,UAAU,GAAGvD,EAAE,CAACwD,YAAY,CAACxD,EAAE,CAACyD,gBAAgB,CAAC;IACvD,MAAMC,SAAS,GAAGtC,IAAI,CAACuC,GAAG,CAACP,WAAW,EAAEC,YAAY,CAAC;IACrD,MAAMO,WAAW,GAAGF,SAAS,GAAGH,UAAU,GAAGA,UAAU,GAAGG,SAAS,GAAG,CAAC;IACvE,MAAMG,gBAAgB,GAAGzC,IAAI,CAACC,KAAK,CAAC+B,WAAW,GAAGQ,WAAW,CAAC;IAC9D,MAAME,iBAAiB,GAAG1C,IAAI,CAACC,KAAK,CAACgC,YAAY,GAAGO,WAAW,CAAC;IAEhE5D,EAAE,CAACyB,WAAW,CAACzB,EAAE,CAAC0B,UAAU,EAAEyB,aAAa,CAAC;IAE5CnD,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAAC4B,cAAc,EAAE5B,EAAE,CAAC6B,aAAa,CAAC;IACpE7B,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAAC8B,cAAc,EAAE9B,EAAE,CAAC6B,aAAa,CAAC;IACpE,IAAIX,WAAW,EAAE;MACflB,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAAC+B,kBAAkB,EAAE/B,EAAE,CAACgC,MAAM,CAAC;MACjEhC,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAACiC,kBAAkB,EAAEjC,EAAE,CAACgC,MAAM,CAAC;IACnE,CAAC,MAAM;MACLhC,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAAC+B,kBAAkB,EAAE/B,EAAE,CAACkC,OAAO,CAAC;MAClElC,EAAE,CAAC2B,aAAa,CAAC3B,EAAE,CAAC0B,UAAU,EAAE1B,EAAE,CAACiC,kBAAkB,EAAEjC,EAAE,CAACkC,OAAO,CAAC;IACpE;IACAlC,EAAE,CAACmC,UAAU,CACXnC,EAAE,CAAC0B,UAAU,EACb,CAAC,EACD1B,EAAE,CAACoC,IAAI,EACPyB,gBAAgB,EAChBC,iBAAiB,EACjB,CAAC,EACD9D,EAAE,CAACoC,IAAI,EACPpB,QAAQ,EACR,IACF,CAAC;IAED,MAAM+C,EAAE,GAAG/D,EAAE,CAACqC,iBAAiB,CAAC,CAAC;IACjCrC,EAAE,CAACsC,eAAe,CAACtC,EAAE,CAACuC,WAAW,EAAEwB,EAAE,CAAC;IACtC/D,EAAE,CAACwC,oBAAoB,CACrBxC,EAAE,CAACuC,WAAW,EACdvC,EAAE,CAACyC,iBAAiB,EACpBzC,EAAE,CAAC0B,UAAU,EACbyB,aAAa,EACb,CACF,CAAC;IACD,MAAMa,WAAW,GAAG,IAAIxF,WAAW,CAACwB,EAAE,CAAC;IAEvCc,OAAO,CAACgC,OAAO,CAAC,UAAUC,GAAG,EAAEC,CAAC,EAAEC,GAAG,EAAE;MACrC,MAAMgB,IAAI,GACR,CAAClB,GAAG,CAACG,MAAM,CAAC,CAAC,CAAC,GAAGL,gBAAgB,CAAC,CAAC,CAAC,IAAIS,WAAW,GAAGM,WAAW;MACnE,MAAMM,IAAI,GACR,EAAEnB,GAAG,CAACG,MAAM,CAAC,CAAC,CAAC,GAAGL,gBAAgB,CAAC,CAAC,CAAC,CAAC,GAAGS,WAAW,GAAGM,WAAW;MACpE,MAAMO,QAAQ,GAAGrF,QAAQ,CAACiE,GAAG,CAACG,MAAM,CAAC,GAAGI,WAAW,GAAGM,WAAW;MACjE,MAAMQ,SAAS,GAAGxF,SAAS,CAACmE,GAAG,CAACG,MAAM,CAAC,GAAGI,WAAW,GAAGM,WAAW;MACnE5D,EAAE,CAACsC,eAAe,CAACtC,EAAE,CAACuC,WAAW,EAAEwB,EAAE,CAAC;MACtC/D,EAAE,CAACqE,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAER,gBAAgB,EAAEC,iBAAiB,CAAC;MAEtD,IAAIf,GAAG,CAACuB,UAAU,EAAE;QAClB,MAAML,IAAI,GACR,CAAClB,GAAG,CAACuB,UAAU,CAAC,CAAC,CAAC,GAAGzB,gBAAgB,CAAC,CAAC,CAAC,IAAIS,WAAW,GAAGM,WAAW;QACvE,MAAMM,IAAI,GACR,EAAEnB,GAAG,CAACuB,UAAU,CAAC,CAAC,CAAC,GAAGzB,gBAAgB,CAAC,CAAC,CAAC,CAAC,GAC1CS,WAAW,GACXM,WAAW;QACb,MAAMxE,KAAK,GAAGN,QAAQ,CAACiE,GAAG,CAACuB,UAAU,CAAC,GAAGhB,WAAW,GAAGM,WAAW;QAClE,MAAMvE,MAAM,GAAGT,SAAS,CAACmE,GAAG,CAACuB,UAAU,CAAC,GAAGhB,WAAW,GAAGM,WAAW;QACpE5D,EAAE,CAACuE,MAAM,CAACvE,EAAE,CAACwE,YAAY,CAAC;QAC1BxE,EAAE,CAACyE,OAAO,CACRvD,WAAW,GAAG+C,IAAI,GAAG7C,IAAI,CAACC,KAAK,CAAC4C,IAAI,CAAC,EACrC/C,WAAW,GAAGgD,IAAI,GAAG9C,IAAI,CAACC,KAAK,CAAC6C,IAAI,CAAC,EACrChD,WAAW,GAAG9B,KAAK,GAAGgC,IAAI,CAACC,KAAK,CAAC4C,IAAI,GAAG7E,KAAK,CAAC,GAAGgC,IAAI,CAACC,KAAK,CAAC4C,IAAI,CAAC,EACjE/C,WAAW,GAAG7B,MAAM,GAAG+B,IAAI,CAACC,KAAK,CAAC6C,IAAI,GAAG7E,MAAM,CAAC,GAAG+B,IAAI,CAACC,KAAK,CAAC6C,IAAI,CACpE,CAAC;MACH;MAEAF,WAAW,CAACU,SAAS,CACnB3B,GAAG,CAACH,OAAO,EACXG,GAAG,CAAC3D,KAAK,EACT2D,GAAG,CAAC1D,MAAM,EACV0B,MAAM,EACNA,MAAM,EACNgC,GAAG,CAAC3D,KAAK,GAAG,CAAC,GAAG2B,MAAM,EACtBgC,GAAG,CAAC1D,MAAM,GAAG,CAAC,GAAG0B,MAAM,EACvBG,WAAW,GAAG+C,IAAI,GAAG7C,IAAI,CAACC,KAAK,CAAC4C,IAAI,CAAC,EACrC/C,WAAW,GAAGgD,IAAI,GAAG9C,IAAI,CAACC,KAAK,CAAC6C,IAAI,CAAC,EACrChD,WAAW,GAAGiD,QAAQ,GAAG/C,IAAI,CAACC,KAAK,CAAC4C,IAAI,GAAGE,QAAQ,CAAC,GAAG/C,IAAI,CAACC,KAAK,CAAC4C,IAAI,CAAC,EACvE/C,WAAW,GACPkD,SAAS,GACThD,IAAI,CAACC,KAAK,CAAC6C,IAAI,GAAGE,SAAS,CAAC,GAAGhD,IAAI,CAACC,KAAK,CAAC6C,IAAI,CAAC,EACnDL,gBAAgB,EAChBC,iBACF,CAAC;MAED9D,EAAE,CAAC2E,OAAO,CAAC3E,EAAE,CAACwE,YAAY,CAAC;IAC7B,CAAC,CAAC;IACFxE,EAAE,CAAC4E,iBAAiB,CAACb,EAAE,CAAC;EAC1B,CAAC,MAAM;IACLZ,aAAa,GAAGrC,OAAO,CAAC,CAAC,CAAC,CAAC8B,OAAO;IAClCQ,WAAW,GAAGtC,OAAO,CAAC,CAAC,CAAC,CAAC1B,KAAK;IAC9BiE,YAAY,GAAGvC,OAAO,CAAC,CAAC,CAAC,CAAC1B,KAAK;EACjC;EAEA,MAAMyF,aAAa,GAAGhG,UAAU,CAAC+B,YAAY,CAAC;EAC9C,MAAMkE,aAAa,GAAGjG,UAAU,CAACgE,gBAAgB,CAAC;EAElD,MAAMkC,MAAM,GAAGA,CACb,2DAA4DC,MAAM,KAC/D;IACH,MAAMC,EAAE,GACL,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGH,aAAa,CAAC,CAAC,CAAC,IAAIlE,gBAAgB,GAAIF,UAAU;IACrE,MAAMyE,EAAE,GACL,EAAEF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGH,aAAa,CAAC,CAAC,CAAC,CAAC,GAAGlE,gBAAgB,GAAIF,UAAU;IACtE,MAAM0E,EAAE,GACL,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGH,aAAa,CAAC,CAAC,CAAC,IAAIlE,gBAAgB,GAAIF,UAAU;IACrE,MAAM2E,EAAE,GACL,EAAEJ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGH,aAAa,CAAC,CAAC,CAAC,CAAC,GAAGlE,gBAAgB,GAAIF,UAAU;IACtE,MAAM4E,EAAE,GACL,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGH,aAAa,CAAC,CAAC,CAAC,IAAIlE,gBAAgB,GAAIF,UAAU;IACrE,MAAM6E,EAAE,GACL,EAAEN,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGH,aAAa,CAAC,CAAC,CAAC,CAAC,GAAGlE,gBAAgB,GAAIF,UAAU;IACtE,OAAO;MAAC0E,EAAE;MAAEC,EAAE;MAAEH,EAAE;MAAEC,EAAE;MAAEG,EAAE;MAAEC;IAAE,CAAC;EACjC,CAAC;EAEDtF,EAAE,CAACsC,eAAe,CAACtC,EAAE,CAACuC,WAAW,EAAEjB,iBAAiB,CAAC;EACrDtB,EAAE,CAACqE,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEjF,KAAK,EAAEC,MAAM,CAAC;;EAEhC;EACA;IACE;IACA,MAAMkG,QAAQ,GAAG,EAAE;IACnB;IACA,MAAMC,SAAS,GAAG,EAAE;IAEpB,MAAMC,UAAU,GAAGhH,aAAa,CAC9BuB,EAAE,EACFd,wBAAwB,EACxBD,sBACF,CAAC;IACDe,EAAE,CAAC0F,UAAU,CAACD,UAAU,CAAC;;IAEzB;IACA,MAAME,eAAe,GAAG3F,EAAE,CAAC4F,kBAAkB,CAACH,UAAU,EAAE,WAAW,CAAC;IACtEzF,EAAE,CAACyB,WAAW,CAACzB,EAAE,CAAC0B,UAAU,EAAEyB,aAAa,CAAC;;IAE5C;IACAnD,EAAE,CAAC6F,SAAS,CAACF,eAAe,EAAE,CAAC,CAAC;;IAEhC;IACA9E,aAAa,CAACiF,YAAY,CAAC,CAAC,CAAChD,OAAO,CAAC,UAAUiD,QAAQ,EAAE/C,CAAC,EAAEC,GAAG,EAAE;MAC/D,MAAM+C,MAAM,GAAGD,QAAQ,CAACC,MAAM;MAC9B,MAAMhB,MAAM,GAAGe,QAAQ,CAACf,MAAM;MAC9B;MACA,MAAM;QAACG,EAAE;QAAEC,EAAE;QAAEH,EAAE;QAAEC,EAAE;QAAEG,EAAE;QAAEC;MAAE,CAAC,GAAGP,MAAM,CAACC,MAAM,CAAC;MAE/C,MAAMiB,GAAG,GACP,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,aAAa,CAAC,CAAC,CAAC,IAAIpE,gBAAgB,GAAG0C,WAAW;MACpE,MAAM8C,GAAG,GACP,EAAEF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,aAAa,CAAC,CAAC,CAAC,CAAC,GAAGpE,gBAAgB,GAAG2C,YAAY;MACtE,MAAM8C,GAAG,GACP,CAACH,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,aAAa,CAAC,CAAC,CAAC,IAAIpE,gBAAgB,GAAG0C,WAAW;MACpE,MAAMgD,GAAG,GACP,EAAEJ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,aAAa,CAAC,CAAC,CAAC,CAAC,GAAGpE,gBAAgB,GAAG2C,YAAY;MACtE,MAAMgD,GAAG,GACP,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,aAAa,CAAC,CAAC,CAAC,IAAIpE,gBAAgB,GAAG0C,WAAW;MACpE,MAAMkD,GAAG,GACP,EAAEN,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGlB,aAAa,CAAC,CAAC,CAAC,CAAC,GAAGpE,gBAAgB,GAAG2C,YAAY;MAEtEkC,QAAQ,CAACgB,IAAI,CAACpB,EAAE,EAAEC,EAAE,EAAEH,EAAE,EAAEC,EAAE,EAAEG,EAAE,EAAEC,EAAE,CAAC;MACrCE,SAAS,CAACe,IAAI,CAACJ,GAAG,EAAEC,GAAG,EAAEH,GAAG,EAAEC,GAAG,EAAEG,GAAG,EAAEC,GAAG,CAAC;IAC9C,CAAC,CAAC;;IAEF;IACA,MAAME,MAAM,GAAGnI,IAAI,CAACoI,YAAY,CAAC,CAAC,EAAErH,KAAK,EAAEC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IAC5D,MAAMqH,cAAc,GAAG1G,EAAE,CAAC4F,kBAAkB,CAACH,UAAU,EAAE,UAAU,CAAC;IACpEzF,EAAE,CAAC2G,gBAAgB,CAACD,cAAc,EAAE,KAAK,EAAEF,MAAM,CAAC;IAElD,MAAMI,gBAAgB,GAAG5G,EAAE,CAAC6G,iBAAiB,CAACpB,UAAU,EAAE,YAAY,CAAC;IACvE,MAAMqB,cAAc,GAAG9G,EAAE,CAAC+G,YAAY,CAAC,CAAC;IACxC/G,EAAE,CAACgH,UAAU,CAAChH,EAAE,CAACiH,YAAY,EAAEH,cAAc,CAAC;IAC9C9G,EAAE,CAACkH,UAAU,CAAClH,EAAE,CAACiH,YAAY,EAAE,IAAIE,YAAY,CAAC5B,QAAQ,CAAC,EAAEvF,EAAE,CAACoH,WAAW,CAAC;IAC1EpH,EAAE,CAACqH,mBAAmB,CAACT,gBAAgB,EAAE,CAAC,EAAE5G,EAAE,CAACsH,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;IAClEtH,EAAE,CAACuH,uBAAuB,CAACX,gBAAgB,CAAC;IAE5C,MAAMY,gBAAgB,GAAGxH,EAAE,CAAC6G,iBAAiB,CAACpB,UAAU,EAAE,YAAY,CAAC;IACvE,MAAMgC,cAAc,GAAGzH,EAAE,CAAC+G,YAAY,CAAC,CAAC;IACxC/G,EAAE,CAACgH,UAAU,CAAChH,EAAE,CAACiH,YAAY,EAAEQ,cAAc,CAAC;IAC9CzH,EAAE,CAACkH,UAAU,CAAClH,EAAE,CAACiH,YAAY,EAAE,IAAIE,YAAY,CAAC3B,SAAS,CAAC,EAAExF,EAAE,CAACoH,WAAW,CAAC;IAC3EpH,EAAE,CAACqH,mBAAmB,CAACG,gBAAgB,EAAE,CAAC,EAAExH,EAAE,CAACsH,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;IAClEtH,EAAE,CAACuH,uBAAuB,CAACC,gBAAgB,CAAC;IAE5CxH,EAAE,CAAC0H,UAAU,CAAC1H,EAAE,CAAC2H,SAAS,EAAE,CAAC,EAAEpC,QAAQ,CAAC9F,MAAM,GAAG,CAAC,CAAC;EACrD;EAEA,IAAIwB,WAAW,EAAE;IACf,MAAM2G,WAAW,GAAGnJ,aAAa,CAC/BuB,EAAE,EACFhB,oBAAoB,EACpBD,kBACF,CAAC;IACDiB,EAAE,CAAC0F,UAAU,CAACkC,WAAW,CAAC;IAC1B,MAAMpB,MAAM,GAAGnI,IAAI,CAACoI,YAAY,CAAC,CAAC,EAAErH,KAAK,EAAEC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IAC5D,MAAMqH,cAAc,GAAG1G,EAAE,CAAC4F,kBAAkB,CAACgC,WAAW,EAAE,UAAU,CAAC;IACrE5H,EAAE,CAAC2G,gBAAgB,CAACD,cAAc,EAAE,KAAK,EAAEF,MAAM,CAAC;IAElD,MAAMqB,OAAO,GAAGC,KAAK,CAACC,OAAO,CAAC9G,WAAW,CAAC,GAAGA,WAAW,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;IACzE,MAAM+G,eAAe,GAAGhI,EAAE,CAAC4F,kBAAkB,CAACgC,WAAW,EAAE,OAAO,CAAC;IACnE,MAAMK,OAAO,GAAG,IAAI;IACpB,IAAIA,OAAO,EAAE;MACXjI,EAAE,CAACkI,UAAU,CAACF,eAAe,EAAEH,OAAO,CAAC;IACzC,CAAC,MAAM;MACL7H,EAAE,CAACmI,UAAU,CAACH,eAAe,EAAEH,OAAO,CAAC;IACzC;IAEA,MAAMjB,gBAAgB,GAAG5G,EAAE,CAAC6G,iBAAiB,CAACe,WAAW,EAAE,YAAY,CAAC;IACxE,MAAMd,cAAc,GAAG9G,EAAE,CAAC+G,YAAY,CAAC,CAAC;IACxC/G,EAAE,CAACgH,UAAU,CAAChH,EAAE,CAACiH,YAAY,EAAEH,cAAc,CAAC;IAC9C9G,EAAE,CAACqH,mBAAmB,CAACT,gBAAgB,EAAE,CAAC,EAAE5G,EAAE,CAACsH,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;IAClEtH,EAAE,CAACuH,uBAAuB,CAACX,gBAAgB,CAAC;;IAE5C;IACA,MAAMwB,KAAK,GAAGvH,aAAa,CAACiF,YAAY,CAAC,CAAC,CAACuC,MAAM,CAAC,UAChD,4BAA6BD,KAAK,EAClCrC,QAAQ,EACR;MACA,MAAMf,MAAM,GAAGe,QAAQ,CAACf,MAAM;MAC9B,MAAM;QAACG,EAAE;QAAEC,EAAE;QAAEH,EAAE;QAAEC,EAAE;QAAEG,EAAE;QAAEC;MAAE,CAAC,GAAGP,MAAM,CAACC,MAAM,CAAC;MAE/C,OAAOoD,KAAK,CAACE,MAAM,CAAC,CAACnD,EAAE,EAAEC,EAAE,EAAEH,EAAE,EAAEC,EAAE,EAAED,EAAE,EAAEC,EAAE,EAAEG,EAAE,EAAEC,EAAE,EAAED,EAAE,EAAEC,EAAE,EAAEH,EAAE,EAAEC,EAAE,CAAC,CAAC;IACvE,CAAC,EAAE,EAAE,CAAC;IACNpF,EAAE,CAACkH,UAAU,CAAClH,EAAE,CAACiH,YAAY,EAAE,IAAIE,YAAY,CAACiB,KAAK,CAAC,EAAEpI,EAAE,CAACoH,WAAW,CAAC;IACvEpH,EAAE,CAAC0H,UAAU,CAAC1H,EAAE,CAACuI,KAAK,EAAE,CAAC,EAAEH,KAAK,CAAC3I,MAAM,GAAG,CAAC,CAAC;EAC9C;EAEA,OAAO;IACLL,KAAK;IACLC,MAAM;IACNsD,WAAW,EAAErB,iBAAiB;IAC9BsB,OAAO,EAAErB;EACX,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}