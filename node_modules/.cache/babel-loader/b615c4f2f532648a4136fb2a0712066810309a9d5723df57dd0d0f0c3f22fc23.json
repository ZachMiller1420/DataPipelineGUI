{"ast":null,"code":"import * as mat4 from '../vec/mat4.js';\n\n/**\n * @module ol/webgl/Canvas\n */\n\nconst VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec4 a_texcoord;\n\n  uniform mat4 u_matrix;\n  uniform mat4 u_textureMatrix;\n\n  varying vec2 v_texcoord;\n\n  void main() {\n    gl_Position = u_matrix * a_position;\n    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;\n    v_texcoord = texcoord;\n  }\n`;\nconst FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (\n      v_texcoord.x < 0.0 ||\n      v_texcoord.y < 0.0 ||\n      v_texcoord.x > 1.0 ||\n      v_texcoord.y > 1.0\n    ) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/** @typedef {import(\"../transform.js\").Transform} Matrix */\n\n/**\n * Canvas-like operations implemented in webgl.\n */\nexport class Canvas {\n  /**\n   * @param {WebGLRenderingContext} gl Context to render in.\n   */\n  constructor(gl) {\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = gl;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.program_ = createProgram(gl, FRAGMENT_SHADER, VERTEX_SHADER);\n    this.positionLocation = gl.getAttribLocation(this.program_, 'a_position');\n    this.texcoordLocation = gl.getAttribLocation(this.program_, 'a_texcoord');\n    this.matrixLocation = gl.getUniformLocation(this.program_, 'u_matrix');\n    this.textureMatrixLocation = gl.getUniformLocation(this.program_, 'u_textureMatrix');\n    this.textureLocation = gl.getUniformLocation(this.program_, 'u_texture');\n    this.positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n    this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.positions), gl.STATIC_DRAW);\n    this.texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n    this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.texcoords), gl.STATIC_DRAW);\n  }\n\n  /**\n   * 2dContext drawImage call implemented in webgl.\n   * Unlike images, textures do not have a width and height associated\n   * with them so we'll pass in the width and height of the texture.\n   *\n   * @param {WebGLTexture} tex Image to draw.\n   * @param {number} texWidth Image width.\n   * @param {number} texHeight Image height.\n   * @param {number} srcX Top-left x-point to read src image.\n   * @param {number} srcY Top-left y-point to read src image.\n   * @param {number} [srcWidth] Width of source to read.\n   * @param {number} [srcHeight] Height of source to read.\n   * @param {number} [dstX] Top-left x-point of destination.\n   * @param {number} [dstY] Top-left y-point of destination.\n   * @param {number} [dstWidth] Width of written image in destination.\n   * @param {number} [dstHeight] Height of written image in destination.\n   * @param {number} [width] Width of canvas.\n   * @param {number} [height] Height of canvas.\n   */\n  drawImage(tex, texWidth, texHeight, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, width, height) {\n    const gl = this.gl_;\n    if (dstX === undefined) {\n      dstX = srcX;\n    }\n    if (dstY === undefined) {\n      dstY = srcY;\n    }\n    if (srcWidth === undefined) {\n      srcWidth = texWidth;\n    }\n    if (srcHeight === undefined) {\n      srcHeight = texHeight;\n    }\n    if (dstWidth === undefined) {\n      dstWidth = srcWidth;\n    }\n    if (dstHeight === undefined) {\n      dstHeight = srcHeight;\n    }\n    if (width === undefined) {\n      width = gl.canvas.width;\n    }\n    if (height === undefined) {\n      height = gl.canvas.height;\n    }\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.useProgram(this.program_);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n    gl.enableVertexAttribArray(this.positionLocation);\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n    gl.enableVertexAttribArray(this.texcoordLocation);\n    gl.vertexAttribPointer(this.texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // matrix for converting pixels to clip space\n    let matrix = mat4.orthographic(0, width, 0, height, -1, 1);\n    matrix = mat4.translate(matrix, dstX, dstY, 0);\n    matrix = mat4.scale(matrix, dstWidth, dstHeight, 1);\n    gl.uniformMatrix4fv(this.matrixLocation, false, matrix);\n    let texMatrix = mat4.translation(srcX / texWidth, srcY / texHeight, 0);\n    texMatrix = mat4.scale(texMatrix, srcWidth / texWidth, srcHeight / texHeight, 1);\n    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\n    gl.uniform1i(this.textureLocation, 0);\n    gl.drawArrays(gl.TRIANGLES, 0, this.positions.length / 2);\n  }\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {GLenum} type Type of shader.\n * @param {string} source source of shader.\n * @return {WebGLShader} [progam] The program.\n */\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (shader === null) {\n    throw new Error('Shader compilation failed');\n  }\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const log = gl.getShaderInfoLog(shader);\n    if (log === null) {\n      throw new Error('Shader info log creation failed');\n    }\n    throw new Error(log);\n  }\n  return shader;\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {string} fragmentSource Fragment shader source.\n * @param {string} vertexSource Vertex shader source.\n * @return {WebGLProgram} [progam] The program.\n */\nexport function createProgram(gl, fragmentSource, vertexSource) {\n  const program = gl.createProgram();\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n  if (program === null) {\n    throw new Error('Program creation failed');\n  }\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const log = gl.getProgramInfoLog(program);\n    if (log === null) {\n      throw new Error('Program info log creation failed');\n    }\n    throw new Error();\n  }\n  return program;\n}","map":{"version":3,"names":["mat4","VERTEX_SHADER","FRAGMENT_SHADER","Canvas","constructor","gl","gl_","program_","createProgram","positionLocation","getAttribLocation","texcoordLocation","matrixLocation","getUniformLocation","textureMatrixLocation","textureLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","positions","bufferData","Float32Array","STATIC_DRAW","texcoordBuffer","texcoords","drawImage","tex","texWidth","texHeight","srcX","srcY","srcWidth","srcHeight","dstX","dstY","dstWidth","dstHeight","width","height","undefined","canvas","bindTexture","TEXTURE_2D","useProgram","enableVertexAttribArray","vertexAttribPointer","FLOAT","matrix","orthographic","translate","scale","uniformMatrix4fv","texMatrix","translation","uniform1i","drawArrays","TRIANGLES","length","createShader","type","source","shader","Error","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","log","getShaderInfoLog","fragmentSource","vertexSource","program","vertexShader","fragmentShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog"],"sources":["C:/Users/zachm/flask-react-frontend/node_modules/ol/webgl/Canvas.js"],"sourcesContent":["import * as mat4 from '../vec/mat4.js';\n\n/**\n * @module ol/webgl/Canvas\n */\n\nconst VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec4 a_texcoord;\n\n  uniform mat4 u_matrix;\n  uniform mat4 u_textureMatrix;\n\n  varying vec2 v_texcoord;\n\n  void main() {\n    gl_Position = u_matrix * a_position;\n    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;\n    v_texcoord = texcoord;\n  }\n`;\n\nconst FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (\n      v_texcoord.x < 0.0 ||\n      v_texcoord.y < 0.0 ||\n      v_texcoord.x > 1.0 ||\n      v_texcoord.y > 1.0\n    ) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/** @typedef {import(\"../transform.js\").Transform} Matrix */\n\n/**\n * Canvas-like operations implemented in webgl.\n */\nexport class Canvas {\n  /**\n   * @param {WebGLRenderingContext} gl Context to render in.\n   */\n  constructor(gl) {\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = gl;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.program_ = createProgram(gl, FRAGMENT_SHADER, VERTEX_SHADER);\n\n    this.positionLocation = gl.getAttribLocation(this.program_, 'a_position');\n    this.texcoordLocation = gl.getAttribLocation(this.program_, 'a_texcoord');\n\n    this.matrixLocation = gl.getUniformLocation(this.program_, 'u_matrix');\n    this.textureMatrixLocation = gl.getUniformLocation(\n      this.program_,\n      'u_textureMatrix',\n    );\n    this.textureLocation = gl.getUniformLocation(this.program_, 'u_texture');\n\n    this.positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n\n    this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.positions),\n      gl.STATIC_DRAW,\n    );\n\n    this.texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n\n    this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.texcoords),\n      gl.STATIC_DRAW,\n    );\n  }\n\n  /**\n   * 2dContext drawImage call implemented in webgl.\n   * Unlike images, textures do not have a width and height associated\n   * with them so we'll pass in the width and height of the texture.\n   *\n   * @param {WebGLTexture} tex Image to draw.\n   * @param {number} texWidth Image width.\n   * @param {number} texHeight Image height.\n   * @param {number} srcX Top-left x-point to read src image.\n   * @param {number} srcY Top-left y-point to read src image.\n   * @param {number} [srcWidth] Width of source to read.\n   * @param {number} [srcHeight] Height of source to read.\n   * @param {number} [dstX] Top-left x-point of destination.\n   * @param {number} [dstY] Top-left y-point of destination.\n   * @param {number} [dstWidth] Width of written image in destination.\n   * @param {number} [dstHeight] Height of written image in destination.\n   * @param {number} [width] Width of canvas.\n   * @param {number} [height] Height of canvas.\n   */\n  drawImage(\n    tex,\n    texWidth,\n    texHeight,\n    srcX,\n    srcY,\n    srcWidth,\n    srcHeight,\n    dstX,\n    dstY,\n    dstWidth,\n    dstHeight,\n    width,\n    height,\n  ) {\n    const gl = this.gl_;\n\n    if (dstX === undefined) {\n      dstX = srcX;\n    }\n    if (dstY === undefined) {\n      dstY = srcY;\n    }\n    if (srcWidth === undefined) {\n      srcWidth = texWidth;\n    }\n    if (srcHeight === undefined) {\n      srcHeight = texHeight;\n    }\n    if (dstWidth === undefined) {\n      dstWidth = srcWidth;\n    }\n    if (dstHeight === undefined) {\n      dstHeight = srcHeight;\n    }\n    if (width === undefined) {\n      width = gl.canvas.width;\n    }\n    if (height === undefined) {\n      height = gl.canvas.height;\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n\n    gl.useProgram(this.program_);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n    gl.enableVertexAttribArray(this.positionLocation);\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n    gl.enableVertexAttribArray(this.texcoordLocation);\n    gl.vertexAttribPointer(this.texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // matrix for converting pixels to clip space\n    let matrix = mat4.orthographic(0, width, 0, height, -1, 1);\n    matrix = mat4.translate(matrix, dstX, dstY, 0);\n    matrix = mat4.scale(matrix, dstWidth, dstHeight, 1);\n    gl.uniformMatrix4fv(this.matrixLocation, false, matrix);\n\n    let texMatrix = mat4.translation(srcX / texWidth, srcY / texHeight, 0);\n    texMatrix = mat4.scale(\n      texMatrix,\n      srcWidth / texWidth,\n      srcHeight / texHeight,\n      1,\n    );\n\n    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\n    gl.uniform1i(this.textureLocation, 0);\n    gl.drawArrays(gl.TRIANGLES, 0, this.positions.length / 2);\n  }\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {GLenum} type Type of shader.\n * @param {string} source source of shader.\n * @return {WebGLShader} [progam] The program.\n */\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n\n  if (shader === null) {\n    throw new Error('Shader compilation failed');\n  }\n\n  gl.shaderSource(shader, source);\n\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const log = gl.getShaderInfoLog(shader);\n    if (log === null) {\n      throw new Error('Shader info log creation failed');\n    }\n    throw new Error(log);\n  }\n\n  return shader;\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {string} fragmentSource Fragment shader source.\n * @param {string} vertexSource Vertex shader source.\n * @return {WebGLProgram} [progam] The program.\n */\nexport function createProgram(gl, fragmentSource, vertexSource) {\n  const program = gl.createProgram();\n\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n  if (program === null) {\n    throw new Error('Program creation failed');\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const log = gl.getProgramInfoLog(program);\n    if (log === null) {\n      throw new Error('Program info log creation failed');\n    }\n    throw new Error();\n  }\n  return program;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}