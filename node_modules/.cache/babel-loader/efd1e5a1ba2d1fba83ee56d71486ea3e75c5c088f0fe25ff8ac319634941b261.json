{"ast":null,"code":"/**\n * @module ol/reproj/DataTile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport DataTile, { asArrayLike, asImageLike, toArray } from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution } from '../reproj.js';\nimport { canvasGLPool, createCanvasContextWebGL, releaseGLCanvas, render as renderReprojected } from './glreproj.js';\nimport { clamp } from '../math.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { getArea, getIntersection, getWidth, wrapAndSliceX } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {import(\"../transform.js\").Transform} [transformMatrix] Source transform matrix.\n * @property {boolean} [renderEdges] Render reprojection edges.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\n      interpolate: options.interpolate,\n      transition: options.transition\n    });\n\n    /**\n     * @private\n     * @type {boolean | Array<number>}\n     */\n    this.renderEdges_ = options.renderEdges !== undefined ? options.renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX() ? sourceTileGridExtent ? getIntersection(sourceProjExtent, sourceTileGridExtent) : sourceProjExtent : sourceTileGridExtent;\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    const targetResolution = this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0]);\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n    const errorThresholdInPixels = options.errorThreshold !== undefined ? options.errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution, options.transformMatrix);\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor((sourceExtent[0] - sourceProjExtent[0]) / worldWidth);\n      }\n      const sourceExtents = wrapAndSliceX(sourceExtent.slice(), sourceProj, true);\n      sourceExtents.forEach(extent => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(extent, this.sourceZ_);\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({\n                tile,\n                offset\n              });\n            }\n          }\n        }\n        ++worldsAway;\n      });\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   * @override\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   * @override\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @override\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    let imageLike = false;\n    this.sourceTiles_.forEach(source => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        imageLike = true;\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = bytesPerElement * tileDataR.length / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: tileDataR,\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n        bandCount: bandCount\n      });\n    });\n    this.sourceTiles_.length = 0;\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n      this.changed();\n      return;\n    }\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const targetWidth = typeof size === 'number' ? size : size[0];\n    const targetHeight = typeof size === 'number' ? size : size[1];\n    const outWidth = targetWidth * this.pixelRatio_;\n    const outHeight = targetHeight * this.pixelRatio_;\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n    const bandCount = dataSources[0].bandCount;\n    const dataR = new dataSources[0].dataType(bandCount * outWidth * outHeight);\n    const gl = createCanvasContextWebGL(outWidth, outHeight, canvasGLPool, {\n      premultipliedAlpha: false,\n      antialias: false\n    });\n    let willInterpolate;\n    const format = gl.RGBA;\n    let textureType;\n    if (dataSources[0].dataType == Float32Array) {\n      textureType = gl.FLOAT;\n      gl.getExtension('WEBGL_color_buffer_float');\n      gl.getExtension('OES_texture_float');\n      gl.getExtension('EXT_float_blend');\n      const extension = gl.getExtension('OES_texture_float_linear');\n      const canInterpolate = extension !== null;\n      willInterpolate = canInterpolate && this.interpolate;\n    } else {\n      textureType = gl.UNSIGNED_BYTE;\n      willInterpolate = this.interpolate;\n    }\n    const BANDS_PR_REPROJ = 4;\n    const reprojs = Math.ceil(bandCount / BANDS_PR_REPROJ);\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n      const sources = [];\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\n        const dataSource = dataSources[i];\n        const pixelSize = dataSource.pixelSize;\n        const width = pixelSize[0];\n        const height = pixelSize[1];\n        const data = new dataSource.dataType(BANDS_PR_REPROJ * width * height);\n        const dataS = dataSource.data;\n        let offset = reproj * BANDS_PR_REPROJ;\n        for (let j = 0, len = data.length; j < len; j += BANDS_PR_REPROJ) {\n          data[j] = dataS[offset];\n          data[j + 1] = dataS[offset + 1];\n          data[j + 2] = dataS[offset + 2];\n          data[j + 3] = dataS[offset + 3];\n          offset += bandCount;\n        }\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        if (willInterpolate) {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        } else {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, textureType, data);\n        sources.push({\n          extent: dataSource.extent,\n          clipExtent: dataSource.clipExtent,\n          texture: texture,\n          width: width,\n          height: height\n        });\n      }\n      const {\n        framebuffer,\n        width,\n        height\n      } = renderReprojected(gl, targetWidth, targetHeight, this.pixelRatio_, sourceResolution, targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, textureType, this.renderEdges_, willInterpolate);\n\n      // The texture is always RGBA.\n      const rows = width;\n      const cols = height * BANDS_PR_REPROJ;\n      const data = new dataSources[0].dataType(rows * cols);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.readPixels(0, 0, width, height, gl.RGBA, textureType, data);\n      let offset = reproj * BANDS_PR_REPROJ;\n      for (let i = 0, len = data.length; i < len; i += BANDS_PR_REPROJ) {\n        // The data read by `readPixels` is flipped in the y-axis so flip it again.\n        const flipY = (rows - 1 - (i / cols | 0)) * cols + i % cols;\n        dataR[offset] = data[flipY];\n        dataR[offset + 1] = data[flipY + 1];\n        dataR[offset + 2] = data[flipY + 2];\n        dataR[offset + 3] = data[flipY + 3];\n        offset += bandCount;\n      }\n    }\n    releaseGLCanvas(gl);\n    canvasGLPool.push(gl.canvas);\n    if (imageLike) {\n      const context = createCanvasContext2D(targetWidth, targetHeight);\n      const imageData = new ImageData(dataR, targetWidth);\n      context.putImageData(imageData, 0, 0);\n      this.reprojData_ = context.canvas;\n    } else {\n      this.reprojData_ = dataR;\n    }\n    this.reprojSize_ = [Math.round(outWidth), Math.round(outHeight)];\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n    let leftToLoad = 0;\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({\n      tile\n    }) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\n        const state = tile.getState();\n        if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      });\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({\n        tile\n      }) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\nexport default ReprojDataTile;","map":{"version":3,"names":["ERROR_THRESHOLD","DataTile","asArrayLike","asImageLike","toArray","EventType","TileState","Triangulation","calculateSourceExtentResolution","canvasGLPool","createCanvasContextWebGL","releaseGLCanvas","render","renderReprojected","clamp","createCanvasContext2D","getArea","getIntersection","getWidth","wrapAndSliceX","listen","unlistenByKey","ReprojDataTile","constructor","options","tileCoord","loader","Promise","resolve","Uint8ClampedArray","interpolate","transition","renderEdges_","renderEdges","undefined","pixelRatio_","pixelRatio","gutter_","gutter","reprojData_","reprojError_","reprojSize_","sourceTileGrid_","sourceTileGrid","targetTileGrid_","targetTileGrid","wrappedTileCoord_","wrappedTileCoord","sourceTiles_","sourcesListenerKeys_","sourceZ_","sourceProj","sourceProjExtent","getExtent","sourceTileGridExtent","clipExtent_","canWrapX","targetExtent","getTileCoordExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","targetResolution","getResolution","targetProj","sourceResolution","isFinite","errorThresholdInPixels","errorThreshold","triangulation_","transformMatrix","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","worldWidth","worldsAway","Math","floor","sourceExtents","slice","forEach","extent","sourceRange","getTileRangeForExtentAndZ","getTile","getTileFunction","srcX","minX","maxX","srcY","minY","maxY","tile","offset","push","getSize","getData","getError","reproject_","dataSources","imageLike","source","getState","LOADED","size","tileData","arrayData","pixelSize","isFloat","Float32Array","pixelCount","DataType","tileDataR","buffer","bytesPerElement","BYTES_PER_ELEMENT","bytesPerPixel","bytesPerRow","byteLength","bandCount","clipExtent","data","dataType","ERROR","changed","z","getTileSize","targetWidth","targetHeight","outWidth","outHeight","dataR","gl","premultipliedAlpha","antialias","willInterpolate","format","RGBA","textureType","FLOAT","getExtension","extension","canInterpolate","UNSIGNED_BYTE","BANDS_PR_REPROJ","reprojs","ceil","reproj","sources","i","len","dataSource","width","height","dataS","j","texture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","framebuffer","rows","cols","bindFramebuffer","FRAMEBUFFER","readPixels","flipY","canvas","context","imageData","ImageData","putImageData","round","load","IDLE","LOADING","leftToLoad","sourceListenKey","CHANGE","unlistenSources_","setTimeout","bind"],"sources":["C:/Users/zachm/flask-react-frontend/node_modules/ol/reproj/DataTile.js"],"sourcesContent":["/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {calculateSourceExtentResolution} from '../reproj.js';\nimport {\n  canvasGLPool,\n  createCanvasContextWebGL,\n  releaseGLCanvas,\n  render as renderReprojected,\n} from './glreproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {import(\"../transform.js\").Transform} [transformMatrix] Source transform matrix.\n * @property {boolean} [renderEdges] Render reprojection edges.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {boolean | Array<number>}\n     */\n    this.renderEdges_ =\n      options.renderEdges !== undefined ? options.renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceTileGridExtent\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\n        : sourceProjExtent\n      : sourceTileGridExtent;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n      options.transformMatrix,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   * @override\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   * @override\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @override\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    let imageLike = false;\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        imageLike = true;\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0],\n      );\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: tileDataR,\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n        bandCount: bandCount,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n      this.changed();\n      return;\n    }\n\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const targetWidth = typeof size === 'number' ? size : size[0];\n    const targetHeight = typeof size === 'number' ? size : size[1];\n    const outWidth = targetWidth * this.pixelRatio_;\n    const outHeight = targetHeight * this.pixelRatio_;\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n\n    const bandCount = dataSources[0].bandCount;\n    const dataR = new dataSources[0].dataType(bandCount * outWidth * outHeight);\n\n    const gl = createCanvasContextWebGL(outWidth, outHeight, canvasGLPool, {\n      premultipliedAlpha: false,\n      antialias: false,\n    });\n\n    let willInterpolate;\n    const format = gl.RGBA;\n    let textureType;\n    if (dataSources[0].dataType == Float32Array) {\n      textureType = gl.FLOAT;\n      gl.getExtension('WEBGL_color_buffer_float');\n      gl.getExtension('OES_texture_float');\n      gl.getExtension('EXT_float_blend');\n      const extension = gl.getExtension('OES_texture_float_linear');\n      const canInterpolate = extension !== null;\n      willInterpolate = canInterpolate && this.interpolate;\n    } else {\n      textureType = gl.UNSIGNED_BYTE;\n      willInterpolate = this.interpolate;\n    }\n\n    const BANDS_PR_REPROJ = 4;\n    const reprojs = Math.ceil(bandCount / BANDS_PR_REPROJ);\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n      const sources = [];\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\n        const dataSource = dataSources[i];\n\n        const pixelSize = dataSource.pixelSize;\n        const width = pixelSize[0];\n        const height = pixelSize[1];\n\n        const data = new dataSource.dataType(BANDS_PR_REPROJ * width * height);\n        const dataS = dataSource.data;\n        let offset = reproj * BANDS_PR_REPROJ;\n        for (let j = 0, len = data.length; j < len; j += BANDS_PR_REPROJ) {\n          data[j] = dataS[offset];\n          data[j + 1] = dataS[offset + 1];\n          data[j + 2] = dataS[offset + 2];\n          data[j + 3] = dataS[offset + 3];\n          offset += bandCount;\n        }\n\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        if (willInterpolate) {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        } else {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          format,\n          width,\n          height,\n          0,\n          format,\n          textureType,\n          data,\n        );\n\n        sources.push({\n          extent: dataSource.extent,\n          clipExtent: dataSource.clipExtent,\n          texture: texture,\n          width: width,\n          height: height,\n        });\n      }\n\n      const {framebuffer, width, height} = renderReprojected(\n        gl,\n        targetWidth,\n        targetHeight,\n        this.pixelRatio_,\n        sourceResolution,\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        textureType,\n        this.renderEdges_,\n        willInterpolate,\n      );\n\n      // The texture is always RGBA.\n      const rows = width;\n      const cols = height * BANDS_PR_REPROJ;\n      const data = new dataSources[0].dataType(rows * cols);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.readPixels(0, 0, width, height, gl.RGBA, textureType, data);\n\n      let offset = reproj * BANDS_PR_REPROJ;\n      for (let i = 0, len = data.length; i < len; i += BANDS_PR_REPROJ) {\n        // The data read by `readPixels` is flipped in the y-axis so flip it again.\n        const flipY = (rows - 1 - ((i / cols) | 0)) * cols + (i % cols);\n        dataR[offset] = data[flipY];\n        dataR[offset + 1] = data[flipY + 1];\n        dataR[offset + 2] = data[flipY + 2];\n        dataR[offset + 3] = data[flipY + 3];\n        offset += bandCount;\n      }\n    }\n\n    releaseGLCanvas(gl);\n    canvasGLPool.push(gl.canvas);\n\n    if (imageLike) {\n      const context = createCanvasContext2D(targetWidth, targetHeight);\n      const imageData = new ImageData(dataR, targetWidth);\n      context.putImageData(imageData, 0, 0);\n      this.reprojData_ = context.canvas;\n    } else {\n      this.reprojData_ = dataR;\n    }\n    this.reprojSize_ = [Math.round(outWidth), Math.round(outHeight)];\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({tile}) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\n        const state = tile.getState();\n        if (\n          state == TileState.LOADED ||\n          state == TileState.ERROR ||\n          state == TileState.EMPTY\n        ) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      });\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({tile}) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}